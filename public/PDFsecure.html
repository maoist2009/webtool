<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PDF ToUnicode 码表置乱工具</title>
    <script src="https://cdn.jsdelivr.net/npm/@tailwindcss/browser@4"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf-lib/1.17.1/pdf-lib.min.js"></script>
    <style>
        .drop-zone {
            transition: all 0.3s ease;
        }
        .drop-zone.dragover {
            border-color: #3b82f6;
            background-color: #eff6ff;
        }
        .log-container {
            font-family: 'Consolas', 'Monaco', monospace;
        }
        /* 自定义滚动条 */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }
        ::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
        }
        ::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 4px;
        }
        ::-webkit-scrollbar-thumb:hover {
            background: rgba(255, 255, 255, 0.5);
        }
    </style>
</head>
<body class="min-h-screen bg-gradient-to-br from-slate-900 via-purple-900 to-slate-900 text-white">
    <div class="container mx-auto px-4 py-8 max-w-4xl">
        <!-- 标题 -->
        <div class="text-center mb-8">
            <h1 class="text-4xl font-bold mb-2 bg-gradient-to-r from-blue-400 to-purple-500 bg-clip-text text-transparent">
                PDF ToUnicode 码表置乱工具
            </h1>
            <p class="text-gray-400">打乱PDF字体映射表，防止文本复制提取 | 支持随机种子控制</p>
        </div>

        <!-- 主面板 -->
        <div class="bg-white/10 backdrop-blur-lg rounded-2xl p-6 shadow-2xl border border-white/20">
            <!-- 上传区域 -->
            <div id="dropZone" class="drop-zone border-2 border-dashed border-gray-500 rounded-xl p-12 text-center cursor-pointer hover:border-blue-400 hover:bg-white/5">
                <div class="flex flex-col items-center gap-4">
                    <svg class="w-16 h-16 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M15 13l-3-3m0 0l-3 3m3-3v12"/>
                    </svg>
                    <div>
                        <p class="text-xl font-medium text-gray-300">拖放PDF文件到此处</p>
                        <p class="text-gray-500 mt-1">或点击选择文件</p>
                    </div>
                </div>
                <input type="file" id="fileInput" accept=".pdf" class="hidden">
            </div>

            <!-- 文件信息 -->
            <div id="fileInfo" class="hidden mt-6 p-4 bg-white/5 rounded-lg">
                <div class="flex items-center justify-between">
                    <div class="flex items-center gap-3">
                        <svg class="w-8 h-8 text-red-400" fill="currentColor" viewBox="0 0 24 24">
                            <path d="M14 2H6a2 2 0 00-2 2v16a2 2 0 002 2h12a2 2 0 002-2V8l-6-6zM6 20V4h7v5h5v11H6z"/>
                        </svg>
                        <div>
                            <p id="fileName" class="font-medium"></p>
                            <p id="fileSize" class="text-sm text-gray-400"></p>
                        </div>
                    </div>
                    <button id="removeFile" class="text-gray-400 hover:text-red-400 transition">
                        <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"/>
                        </svg>
                    </button>
                </div>
            </div>

            <!-- 选项 -->
            <div class="mt-6 p-4 bg-white/5 rounded-lg space-y-4">
                <div class="flex flex-wrap gap-6">
                    <div class="flex items-center gap-3">
                        <input type="checkbox" id="removeBookmarks" checked class="w-5 h-5 rounded bg-white/10 border-gray-500 text-blue-500 focus:ring-blue-500 cursor-pointer">
                        <label for="removeBookmarks" class="text-gray-300 cursor-pointer select-none">删除书签</label>
                    </div>
                    <div class="flex items-center gap-3">
                        <input type="checkbox" id="removeMetadata" checked class="w-5 h-5 rounded bg-white/10 border-gray-500 text-blue-500 focus:ring-blue-500 cursor-pointer">
                        <label for="removeMetadata" class="text-gray-300 cursor-pointer select-none">清除元数据</label>
                    </div>
                </div>
                
                <div class="border-t border-white/10 pt-4">
                    <div class="flex flex-col sm:flex-row sm:items-center gap-3">
                        <label class="text-gray-300 whitespace-nowrap text-sm">随机种子 (Seed):</label>
                        <div class="flex items-center gap-2 flex-1 max-w-md">
                            <input type="text" id="randomSeed" class="flex-1 bg-black/20 border border-gray-600 rounded px-3 py-1.5 text-white text-sm focus:outline-none focus:border-blue-400 font-mono" placeholder="留空自动生成">
                            <button id="refreshSeedBtn" class="p-2 text-gray-400 hover:text-blue-400 hover:bg-white/10 rounded transition" title="生成新种子">
                                <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15"/>
                                </svg>
                            </button>
                        </div>
                        <span class="text-xs text-gray-500">相同种子可复现相同的乱码映射</span>
                    </div>
                </div>
            </div>

            <!-- 处理按钮 -->
            <button id="processBtn" disabled class="mt-6 w-full py-4 bg-gradient-to-r from-blue-500 to-purple-600 rounded-xl font-bold text-lg disabled:opacity-50 disabled:cursor-not-allowed hover:from-blue-600 hover:to-purple-700 transition-all transform hover:scale-[1.02] active:scale-[0.98]">
                开始处理
            </button>

            <!-- 进度条 -->
            <div id="progressContainer" class="hidden mt-6">
                <div class="flex justify-between text-sm text-gray-400 mb-2">
                    <span>处理进度</span>
                    <span id="progressText">0%</span>
                </div>
                <div class="w-full bg-gray-700 rounded-full h-3 overflow-hidden">
                    <div id="progressBar" class="bg-gradient-to-r from-blue-500 to-purple-500 h-full rounded-full transition-all duration-300" style="width: 0%"></div>
                </div>
            </div>

            <!-- 日志区域 -->
            <div id="logContainer" class="hidden mt-6">
                <div class="flex justify-between items-end mb-2">
                    <h3 class="text-gray-300 font-medium">处理日志</h3>
                    <button id="copyLogBtn" class="flex items-center gap-1.5 px-3 py-1 text-xs rounded bg-white/5 hover:bg-white/10 text-blue-400 hover:text-blue-300 transition border border-white/10">
                        <svg class="w-3.5 h-3.5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 5H6a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2v-1M8 5a2 2 0 002 2h2a2 2 0 002-2M8 5a2 2 0 012-2h2a2 2 0 012 2m0 0h2a2 2 0 012 2v3m2 4H10m0 0l3-3m-3 3l3 3"/>
                        </svg>
                        <span>复制日志</span>
                    </button>
                </div>
                <div id="logArea" class="log-container bg-black/30 rounded-lg p-4 h-48 overflow-y-auto text-sm text-gray-300 space-y-1 border border-white/5">
                </div>
            </div>

            <!-- 下载区域 -->
            <div id="downloadContainer" class="hidden mt-6 p-4 bg-green-500/20 rounded-lg border border-green-500/30">
                <div class="flex items-center justify-between">
                    <div class="flex items-center gap-3">
                        <svg class="w-8 h-8 text-green-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z"/>
                        </svg>
                        <span class="text-green-300 font-medium">处理完成！</span>
                    </div>
                    <button id="downloadBtn" class="px-6 py-2 bg-green-500 hover:bg-green-600 rounded-lg font-medium transition shadow-lg shadow-green-500/30">
                        下载文件
                    </button>
                </div>
            </div>
        </div>

        <!-- 说明 -->
        <div class="mt-8 bg-white/5 backdrop-blur rounded-xl p-6 border border-white/10">
            <h2 class="text-xl font-bold mb-4 text-blue-400">工作原理</h2>
            <ul class="space-y-2 text-gray-300">
                <li class="flex items-start gap-2">
                    <span class="text-purple-400">•</span>
                    <span>通过打乱PDF字体 ToUnicode 映射表，使复制的文本变成乱码</span>
                </li>
                <li class="flex items-start gap-2">
                    <span class="text-purple-400">•</span>
                    <span>支持自定义随机种子，相同种子可复现相同的乱码结果</span>
                </li>
                <li class="flex items-start gap-2">
                    <span class="text-purple-400">•</span>
                    <span>自动删除书签和元数据，进一步保护文档隐私</span>
                </li>
            </ul>
            <p class="mt-4 text-yellow-400/80 text-sm flex items-center gap-2">
                <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z"/>
                </svg>
                注意：所有处理在浏览器本地完成，文件不会上传到任何服务器
            </p>
        </div>
    </div>

    <script>
        const { PDFDocument, PDFName, PDFDict, PDFStream, PDFRawStream, PDFRef, PDFArray } = PDFLib;
        
        let selectedFile = null;
        let processedPdfBytes = null;

        // DOM 元素
        const dropZone = document.getElementById('dropZone');
        const fileInput = document.getElementById('fileInput');
        const fileInfo = document.getElementById('fileInfo');
        const fileName = document.getElementById('fileName');
        const fileSize = document.getElementById('fileSize');
        const removeFileBtn = document.getElementById('removeFile');
        const processBtn = document.getElementById('processBtn');
        const progressContainer = document.getElementById('progressContainer');
        const progressBar = document.getElementById('progressBar');
        const progressText = document.getElementById('progressText');
        const logContainer = document.getElementById('logContainer');
        const logArea = document.getElementById('logArea');
        const downloadContainer = document.getElementById('downloadContainer');
        const downloadBtn = document.getElementById('downloadBtn');
        const randomSeedInput = document.getElementById('randomSeed');
        const refreshSeedBtn = document.getElementById('refreshSeedBtn');
        const copyLogBtn = document.getElementById('copyLogBtn');

        // 随机数生成器 (Mulberry32)
        function mulberry32(a) {
            return function() {
              var t = a += 0x6D2B79F5;
              t = Math.imul(t ^ (t >>> 15), t | 1);
              t ^= t + Math.imul(t ^ (t >>> 7), t | 61);
              return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
            }
        }

        // 种子生成器 (xmur3)
        function xmur3(str) {
            for(var i = 0, h = 1779033703 ^ str.length; i < str.length; i++)
                h = Math.imul(h ^ str.charCodeAt(i), 3432918353),
                h = h << 13 | h >>> 19;
            return function() {
                h = Math.imul(h ^ (h >>> 16), 2246822507);
                h = Math.imul(h ^ (h >>> 13), 3266489909);
                return (h ^= h >>> 16) >>> 0;
            }
        }

        // 生成随机字符串
        function generateRandomSeed() {
            return Math.random().toString(36).substring(2, 10).toUpperCase();
        }

        // 更新种子输入框
        refreshSeedBtn.addEventListener('click', () => {
            randomSeedInput.value = generateRandomSeed();
            // 闪烁效果提示已更新
            randomSeedInput.classList.add('bg-blue-500/20');
            setTimeout(() => randomSeedInput.classList.remove('bg-blue-500/20'), 300);
        });

        // 复制日志
        copyLogBtn.addEventListener('click', () => {
            const text = logArea.innerText;
            navigator.clipboard.writeText(text).then(() => {
                const originalContent = copyLogBtn.innerHTML;
                copyLogBtn.innerHTML = `
                    <svg class="w-3.5 h-3.5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7"/>
                    </svg>
                    <span>已复制</span>
                `;
                copyLogBtn.classList.add('text-green-400', 'border-green-400/50');
                setTimeout(() => {
                    copyLogBtn.innerHTML = originalContent;
                    copyLogBtn.classList.remove('text-green-400', 'border-green-400/50');
                }, 2000);
            }).catch(err => {
                console.error('复制失败:', err);
            });
        });

        // 拖放处理
        dropZone.addEventListener('click', () => fileInput.click());
        
        dropZone.addEventListener('dragover', (e) => {
            e.preventDefault();
            dropZone.classList.add('dragover');
        });

        dropZone.addEventListener('dragleave', () => {
            dropZone.classList.remove('dragover');
        });

        dropZone.addEventListener('drop', (e) => {
            e.preventDefault();
            dropZone.classList.remove('dragover');
            const files = e.dataTransfer.files;
            if (files.length > 0 && files[0].type === 'application/pdf') {
                handleFile(files[0]);
            }
        });

        fileInput.addEventListener('change', (e) => {
            if (e.target.files.length > 0) {
                handleFile(e.target.files[0]);
            }
        });

        removeFileBtn.addEventListener('click', resetUI);

        function handleFile(file) {
            selectedFile = file;
            fileName.textContent = file.name;
            fileSize.textContent = formatSize(file.size);
            fileInfo.classList.remove('hidden');
            processBtn.disabled = false;
            downloadContainer.classList.add('hidden');
            logArea.innerHTML = '';
        }

        function formatSize(bytes) {
            if (bytes < 1024) return bytes + ' B';
            if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(2) + ' KB';
            return (bytes / (1024 * 1024)).toFixed(2) + ' MB';
        }

        function resetUI() {
            selectedFile = null;
            processedPdfBytes = null;
            fileInput.value = '';
            fileInfo.classList.add('hidden');
            processBtn.disabled = true;
            progressContainer.classList.add('hidden');
            logContainer.classList.add('hidden');
            downloadContainer.classList.add('hidden');
            logArea.innerHTML = '';
            setProgress(0);
        }

        function log(message, type = 'info') {
            const colors = {
                info: 'text-gray-300',
                success: 'text-green-400',
                warning: 'text-yellow-400',
                error: 'text-red-400'
            };
            const time = new Date().toLocaleTimeString();
            const div = document.createElement('div');
            div.className = colors[type] || colors.info;
            div.textContent = `[${time}] ${message}`;
            logArea.appendChild(div);
            logArea.scrollTop = logArea.scrollHeight;
        }

        function setProgress(percent) {
            progressBar.style.width = percent + '%';
            progressText.textContent = percent + '%';
        }

        // Fisher-Yates 洗牌算法 (带自定义随机函数)
        function shuffle(array, randomFunc) {
            const arr = [...array];
            for (let i = arr.length - 1; i > 0; i--) {
                const j = Math.floor(randomFunc() * (i + 1));
                [arr[i], arr[j]] = [arr[j], arr[i]];
            }
            return arr;
        }

        // 生成置乱的 ToUnicode CMap
        function generateScrambledCMap(randomFunc) {
            const codes = Array.from({ length: 256 }, (_, i) => i);
            // 使用传入的随机函数进行洗牌
            const unis = shuffle(codes, randomFunc);
            
            let cmap = `/CIDInit /ProcSet findresource begin
12 dict begin
begincmap
/CIDSystemInfo << /Registry (Adobe) /Ordering (UCS) /Supplement 0 >> def
/CMapName /Adobe-Identity-UCS def
/CMapType 2 def
1 begincodespacerange
<00> <FF>
endcodespacerange
256 beginbfchar
`;
            for (let i = 0; i < 256; i++) {
                const cid = i.toString(16).padStart(2, '0').toUpperCase();
                const uni = unis[i].toString(16).padStart(4, '0').toUpperCase();
                cmap += `<${cid}> <${uni}>\n`;
            }
            
            cmap += `endbfchar
endcmap
CMapName currentdict /CMap defineresource pop
end
end
`;
            return new TextEncoder().encode(cmap);
        }

        // 递归遍历字典查找 ToUnicode
        function findAndScrambleToUnicode(obj, context, visited = new Set(), depth = 0, randomFunc) {
            if (depth > 50) return 0; // 防止无限递归
            
            let count = 0;
            
            if (!obj || typeof obj !== 'object') return count;
            
            // 避免循环引用
            const objId = obj.toString?.() || String(obj);
            if (visited.has(objId)) return count;
            visited.add(objId);
            
            try {
                // 检查是否是字体字典
                if (obj instanceof PDFDict) {
                    const type = obj.get(PDFName.of('Type'));
                    const subtype = obj.get(PDFName.of('Subtype'));
                    
                    const isFont = (type && type.toString() === '/Font') || 
                                   (subtype && ['/Type0', '/Type1', '/TrueType', '/CIDFontType0', '/CIDFontType2'].includes(subtype.toString()));
                    
                    if (isFont) {
                        const toUnicode = obj.get(PDFName.of('ToUnicode'));
                        if (toUnicode) {
                            try {
                                // 获取流对象
                                let streamObj = toUnicode;
                                if (toUnicode instanceof PDFRef) {
                                    streamObj = context.lookup(toUnicode);
                                }
                                
                                if (streamObj && typeof streamObj.getContents === 'function') {
                                    // 生成新的置乱CMap并替换，传入随机函数
                                    const newCmapBytes = generateScrambledCMap(randomFunc);
                                    
                                    // 创建新的流内容
                                    const newStream = context.flateStream(newCmapBytes);
                                    
                                    // 替换引用
                                    if (toUnicode instanceof PDFRef) {
                                        context.assign(toUnicode, newStream);
                                    }
                                    count++;
                                }
                            } catch (e) {
                                // 忽略单个流处理错误
                            }
                        }
                    }
                    
                    // 递归处理字典中的值
                    const entries = obj.entries?.() || [];
                    for (const [key, value] of entries) {
                        if (value instanceof PDFRef) {
                            const resolved = context.lookup(value);
                            count += findAndScrambleToUnicode(resolved, context, visited, depth + 1, randomFunc);
                        } else {
                            count += findAndScrambleToUnicode(value, context, visited, depth + 1, randomFunc);
                        }
                    }
                }
                
                // 处理数组
                if (obj instanceof PDFArray) {
                    const size = obj.size?.() || 0;
                    for (let i = 0; i < size; i++) {
                        const item = obj.get(i);
                        if (item instanceof PDFRef) {
                            const resolved = context.lookup(item);
                            count += findAndScrambleToUnicode(resolved, context, visited, depth + 1, randomFunc);
                        } else {
                            count += findAndScrambleToUnicode(item, context, visited, depth + 1, randomFunc);
                        }
                    }
                }
            } catch (e) {
                // 忽略处理错误
            }
            
            return count;
        }

        // 处理PDF
        async function processPDF() {
            if (!selectedFile) return;
            
            processBtn.disabled = true;
            progressContainer.classList.remove('hidden');
            logContainer.classList.remove('hidden');
            downloadContainer.classList.add('hidden');
            logArea.innerHTML = '';
            
            try {
                // 处理随机种子
                let seed = randomSeedInput.value.trim();
                if (!seed) {
                    seed = generateRandomSeed();
                    randomSeedInput.value = seed;
                    log(`自动生成随机种子: ${seed}`, 'info');
                } else {
                    log(`使用指定随机种子: ${seed}`, 'info');
                }
                
                // 初始化 PRNG
                const seedFunc = xmur3(seed);
                const randomFunc = mulberry32(seedFunc());
                
                log('开始读取PDF文件...');
                setProgress(10);
                
                const arrayBuffer = await selectedFile.arrayBuffer();
                const pdfDoc = await PDFDocument.load(arrayBuffer, { 
                    ignoreEncryption: true,
                    updateMetadata: false 
                });
                
                log(`PDF加载成功，共 ${pdfDoc.getPageCount()} 页`);
                setProgress(20);
                
                const context = pdfDoc.context;
                
                // 删除书签
                if (document.getElementById('removeBookmarks').checked) {
                    log('正在删除书签...');
                    try {
                        const catalog = pdfDoc.catalog;
                        if (catalog.has(PDFName.of('Outlines'))) {
                            catalog.delete(PDFName.of('Outlines'));
                            log('书签已删除', 'success');
                        } else {
                            log('未发现书签', 'info');
                        }
                    } catch (e) {
                        log('删除书签时出错: ' + e.message, 'warning');
                    }
                }
                setProgress(30);
                
                // 清除元数据
                if (document.getElementById('removeMetadata').checked) {
                    log('正在清除元数据...');
                    try {
                        pdfDoc.setTitle('');
                        pdfDoc.setAuthor('');
                        pdfDoc.setSubject('');
                        pdfDoc.setKeywords([]);
                        pdfDoc.setProducer('');
                        pdfDoc.setCreator('');
                        log('元数据已清除', 'success');
                    } catch (e) {
                        log('清除元数据时出错: ' + e.message, 'warning');
                    }
                }
                setProgress(40);
                
                // 查找并置乱 ToUnicode
                log('正在查找并置乱ToUnicode映射表...');
                
                let scrambledCount = 0;
                const pages = pdfDoc.getPages();
                
                for (let i = 0; i < pages.length; i++) {
                    const page = pages[i];
                    const resources = page.node.get(PDFName.of('Resources'));
                    
                    if (resources) {
                        const resourcesObj = resources instanceof PDFRef ? context.lookup(resources) : resources;
                        
                        if (resourcesObj instanceof PDFDict) {
                            const fonts = resourcesObj.get(PDFName.of('Font'));
                            if (fonts) {
                                const fontsObj = fonts instanceof PDFRef ? context.lookup(fonts) : fonts;
                                // 传递 randomFunc
                                scrambledCount += findAndScrambleToUnicode(fontsObj, context, new Set(), 0, randomFunc);
                            }
                        }
                    }
                    
                    setProgress(40 + Math.floor((i + 1) / pages.length * 40));
                }
                
                log(`已置乱 ${scrambledCount} 个ToUnicode映射表`, scrambledCount > 0 ? 'success' : 'warning');
                setProgress(85);
                
                // 保存PDF
                log('正在生成新的PDF文件...');
                processedPdfBytes = await pdfDoc.save();
                
                setProgress(100);
                log(`处理完成！输出文件大小: ${formatSize(processedPdfBytes.length)}`, 'success');
                
                downloadContainer.classList.remove('hidden');
                
            } catch (error) {
                log('处理失败: ' + error.message, 'error');
                console.error(error);
            } finally {
                processBtn.disabled = false;
            }
        }

        // 下载处理后的PDF
        function downloadPDF() {
            if (!processedPdfBytes) return;
            
            const seed = randomSeedInput.value.trim() || 'random';
            const blob = new Blob([processedPdfBytes], { type: 'application/pdf' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            // 文件名加上种子信息以便识别
            const baseName = selectedFile.name.replace(/\.pdf$/i, '');
            a.download = `${baseName}_scrambled_${seed}.pdf`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        processBtn.addEventListener('click', processPDF);
        downloadBtn.addEventListener('click', downloadPDF);
    </script>
</body>
</html>